#include "xml.h"

//-----------------------------------------------------------------------
// This file is part of the Windows SDK Code Samples.
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// This source code is intended only as a supplement to Microsoft
// Development Tools and/or on-line documentation.  See these other
// materials for detailed information regarding Microsoft code samples.
//
// THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

#include <ole2.h>
#include <xmllite.h>
#include <stdio.h>
#include <shlwapi.h>

#pragma warning(disable : 4127) // conditional expression is constant
#define CHKHR(stmt)       \
    do {                  \
        hr = (stmt);      \
        if (FAILED(hr))   \
            goto CleanUp; \
    } while (0)
#define HR(stmt)      \
    do {              \
        hr = (stmt);  \
        goto CleanUp; \
    } while (0)
#define SAFE_RELEASE(I)   \
    do {                  \
        if (I) {          \
            I->Release(); \
        }                 \
        I = NULL;         \
    } while (0)


HRESULT WriteAttributes(IXmlReader * pReader)
{
    const WCHAR * pwszPrefix;
    const WCHAR * pwszLocalName;
    const WCHAR * pwszValue;
    HRESULT hr = pReader->MoveToFirstAttribute();

    if (S_FALSE == hr)
        return hr;

    if (S_OK != hr) {
        wprintf(L"Error moving to first attribute, error is %08.8lx", hr);
        return hr;
    } else {
        while (TRUE) {
            if (!pReader->IsDefault()) {
                UINT cwchPrefix;
                if (FAILED(hr = pReader->GetPrefix(&pwszPrefix, &cwchPrefix))) {
                    wprintf(L"Error getting prefix, error is %08.8lx", hr);
                    return hr;
                }

                if (FAILED(hr = pReader->GetLocalName(&pwszLocalName, NULL))) {
                    wprintf(L"Error getting local name, error is %08.8lx", hr);
                    return hr;
                }

                if (FAILED(hr = pReader->GetValue(&pwszValue, NULL))) {
                    wprintf(L"Error getting value, error is %08.8lx", hr);
                    return hr;
                }

                //if (cwchPrefix > 0)
                //    wprintf(L"Attr: %s:%s=\"%s\" \n", pwszPrefix, pwszLocalName, pwszValue);
                //else
                //    wprintf(L"Attr: %s=\"%s\" \n", pwszLocalName, pwszValue);
            }

            if (S_OK != pReader->MoveToNextAttribute())
                break;
        }
    }

    return hr;
}


int ParseXml(LPWSTR pProfileXml, wstring & keyMaterial)
/*
\Windows-classic-samples\Samples\XmlLiteReader\cpp\XmlLiteReader.cpp

https://learn.microsoft.com/zh-cn/windows/win32/api/shlwapi/nf-shlwapi-shcreatememstream
https://learn.microsoft.com/zh-cn/windows/win32/api/combaseapi/nf-combaseapi-createstreamonhglobal
https://stackoverflow.com/questions/8804687/unable-to-read-xml-string-with-xmllite-using-memory-buffer
*/
{
    HRESULT hr = S_OK;
    IStream * pFileStream = SHCreateMemStream((const BYTE *)pProfileXml, lstrlen(pProfileXml) * sizeof(WCHAR));
    IXmlReader * pReader = NULL;
    XmlNodeType nodeType;
    const WCHAR * pwszPrefix;
    const WCHAR * pwszLocalName{};
    const WCHAR * pwszValue;
    UINT cwchPrefix;

    //if (argc != 2) {
    //    wprintf(L"Usage: XmlLiteReader.exe name-of-input-file\n");
    //    return 0;
    //}

    ////Open read-only input stream
    //if (FAILED(hr = SHCreateStreamOnFile(argv[1], STGM_READ, &pFileStream))) {
    //    wprintf(L"Error creating file reader, error is %08.8lx", hr);
    //    HR(hr);
    //}

    if (FAILED(hr = CreateXmlReader(__uuidof(IXmlReader), (void **)&pReader, NULL))) {
        wprintf(L"Error creating xml reader, error is %08.8lx", hr);
        HR(hr);
    }

    if (FAILED(hr = pReader->SetProperty(XmlReaderProperty_DtdProcessing, DtdProcessing_Prohibit))) {
        wprintf(L"Error setting XmlReaderProperty_DtdProcessing, error is %08.8lx", hr);
        HR(hr);
    }

    if (FAILED(hr = pReader->SetInput(pFileStream))) {
        wprintf(L"Error setting input for reader, error is %08.8lx", hr);
        HR(hr);
    }

    //read until there are no more nodes
    while (S_OK == (hr = pReader->Read(&nodeType))) {
        switch (nodeType) {
        case XmlNodeType_XmlDeclaration:
            //wprintf(L"XmlDeclaration\n");
            if (FAILED(hr = WriteAttributes(pReader))) {
                wprintf(L"Error writing attributes, error is %08.8lx", hr);
                HR(hr);
            }
            break;
        case XmlNodeType_Element:
            if (FAILED(hr = pReader->GetPrefix(&pwszPrefix, &cwchPrefix))) {
                wprintf(L"Error getting prefix, error is %08.8lx", hr);
                HR(hr);
            }

            if (FAILED(hr = pReader->GetLocalName(&pwszLocalName, NULL))) {
                wprintf(L"Error getting local name, error is %08.8lx", hr);
                HR(hr);
            }

            //if (cwchPrefix > 0)
            //    wprintf(L"Element: %s:%s\n", pwszPrefix, pwszLocalName);
            //else
            //    wprintf(L"Element: %s\n", pwszLocalName);

            if (FAILED(hr = WriteAttributes(pReader))) {
                wprintf(L"Error writing attributes, error is %08.8lx", hr);
                HR(hr);
            }

            if (pReader->IsEmptyElement())
                wprintf(L" (empty)");

            break;
        case XmlNodeType_EndElement:
            if (FAILED(hr = pReader->GetPrefix(&pwszPrefix, &cwchPrefix))) {
                wprintf(L"Error getting prefix, error is %08.8lx", hr);
                HR(hr);
            }

            if (FAILED(hr = pReader->GetLocalName(&pwszLocalName, NULL))) {
                wprintf(L"Error getting local name, error is %08.8lx", hr);
                HR(hr);
            }

            //if (cwchPrefix > 0)
            //    wprintf(L"End Element: %s:%s\n", pwszPrefix, pwszLocalName);
            //else
            //    wprintf(L"End Element: %s\n", pwszLocalName);

            break;
        case XmlNodeType_Text:
        case XmlNodeType_Whitespace:
            if (FAILED(hr = pReader->GetValue(&pwszValue, NULL))) {
                wprintf(L"Error getting value, error is %08.8lx", hr);
                HR(hr);
            }
            //wprintf(L"Text: >%s<\n", pwszValue);

            if (pwszLocalName && pwszValue && _wcsicmp(pwszLocalName, L"keyMaterial") == 0) {
                keyMaterial += pwszValue;
                break; //建议直接退出，不过加几个回车换行也不影响解密。
                //return 0;
            }

            break;
        case XmlNodeType_CDATA:
            if (FAILED(hr = pReader->GetValue(&pwszValue, NULL))) {
                wprintf(L"Error getting value, error is %08.8lx", hr);
                HR(hr);
            }
            wprintf(L"CDATA: %s\n", pwszValue);
            break;
        case XmlNodeType_ProcessingInstruction:
            if (FAILED(hr = pReader->GetLocalName(&pwszLocalName, NULL))) {
                wprintf(L"Error getting name, error is %08.8lx", hr);
                HR(hr);
            }
            if (FAILED(hr = pReader->GetValue(&pwszValue, NULL))) {
                wprintf(L"Error getting value, error is %08.8lx", hr);
                HR(hr);
            }
            wprintf(L"Processing Instruction name:%s value:%s\n", pwszLocalName, pwszValue);
            break;
        case XmlNodeType_Comment:
            if (FAILED(hr = pReader->GetValue(&pwszValue, NULL))) {
                wprintf(L"Error getting value, error is %08.8lx", hr);
                HR(hr);
            }
            wprintf(L"Comment: %s\n", pwszValue);
            break;
        case XmlNodeType_DocumentType:
            wprintf(L"DOCTYPE is not printed\n");
            break;
        }
    }

CleanUp:
    //SAFE_RELEASE(pFileStream);
    SAFE_RELEASE(pReader);
    return hr;
}
